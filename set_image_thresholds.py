# -*- coding: utf-8 -*-
"""set_image_thresholds

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qnQnr_LcPa80y9ks-E5CBSaB66KSasdV
"""

from google.colab import drive
drive.mount('image_thresholds')

import cv2
import numpy as np
import os
from PIL import Image
def load_and_preprocess_image(path):
    img = cv2.imread(path)
    pil_img = Image.fromarray(img)
    resized_img = pil_img.resize((256, 256), Image.ANTIALIAS)
    # PIL 이미지를 NumPy 배열로 변환
    resized_img_np = np.array(resized_img)
    # OpenCV는 BGR 형식을 사용하므로 색상 순서를 변경
    resized_img_np = cv2.cvtColor(resized_img_np, cv2.COLOR_RGB2BGR)
    hsv = cv2.cvtColor(resized_img_np, cv2.COLOR_BGR2HSV)
    hist = cv2.calcHist([hsv], [0], None, [256], [0, 256])
    cv2.normalize(hist, hist, 0, 1, cv2.NORM_MINMAX)
    return hist

def load_images_from_folder(folder_path):
    images = []
    for filename in os.listdir(folder_path):
        img = load_and_preprocess_image(os.path.join(folder_path, filename))
        if img is not None:
            images.append(img)
    return images

# 유사도 계산 함수
def calculate_similarity_by_corr(hist1, hist2, method=cv2.HISTCMP_CORREL):
    return cv2.compareHist(hist1, hist2, method)

def calculate_similarity_by_bhat(hist1, hist2, method=cv2.HISTCMP_BHATTACHARYYA):
    return cv2.compareHist(hist1, hist2, method)

base_path = '/content/image_thresholds/MyDrive/image'  # 이미지 폴더 경로 수정

categories = os.listdir(base_path)


City_real_images_path = os.path.join(base_path,  'City')
City_k_frame_images_path = os.path.join(base_path,  'City Frame/k')
City_hi_frame_images_path = os.path.join(base_path,  'City Frame/hi')

City_real_images = load_images_from_folder(City_real_images_path)
City_k_frame_images = load_images_from_folder(City_k_frame_images_path)
City_hi_frame_images = load_images_from_folder(City_hi_frame_images_path)
City_Frame_images = City_k_frame_images + City_hi_frame_images

Ocean_real_images_path = os.path.join(base_path,  'Ocean')
Ocean_k_frame_images_path = os.path.join(base_path,  'Ocean Frame/k')
Ocean_hi_frame_images_path = os.path.join(base_path,  'Ocean Frame/hi')

Ocean_real_images = load_images_from_folder(Ocean_real_images_path)
Ocean_k_frame_images = load_images_from_folder(Ocean_k_frame_images_path)
Ocean_hi_frame_images = load_images_from_folder(Ocean_hi_frame_images_path)
Ocean_Frame_images = Ocean_k_frame_images + Ocean_hi_frame_images

desert_real_images_path = os.path.join(base_path,  'desert')
desert_k_frame_images_path = os.path.join(base_path,  'desert Frame/k')
desert_hi_frame_images_path = os.path.join(base_path,  'desert Frame/hi')

desert_real_images = load_images_from_folder(desert_real_images_path)
desert_k_frame_images = load_images_from_folder(desert_k_frame_images_path)
desert_hi_frame_images = load_images_from_folder(desert_hi_frame_images_path)

desert_Frame_images = desert_k_frame_images + desert_hi_frame_images

grassland_real_images_path = os.path.join(base_path,  'grassland')
grassland_k_frame_images_path = os.path.join(base_path,  'grassland Frame/k')
grassland_hi_frame_images_path = os.path.join(base_path,  'grassland Frame/hi')

grassland_real_images = load_images_from_folder(grassland_real_images_path)
grassland_k_frame_images = load_images_from_folder(grassland_k_frame_images_path)
grassland_hi_frame_images = load_images_from_folder(grassland_hi_frame_images_path)

grassland_Frame_images = grassland_k_frame_images + grassland_hi_frame_images


mountain_real_images_path = os.path.join(base_path,  'mountain')
mountain_k_frame_images_path = os.path.join(base_path,  'mountain Frame/k')
mountain_hi_frame_images_path = os.path.join(base_path,  'mountain Frame/hi')

mountain_real_images = load_images_from_folder(mountain_real_images_path)
mountain_k_frame_images = load_images_from_folder(mountain_k_frame_images_path)
mountain_hi_frame_images = load_images_from_folder(mountain_hi_frame_images_path)

mountain_Frame_images = mountain_k_frame_images + mountain_hi_frame_images


snow_real_images_path = os.path.join(base_path,  'snow')
snow_k_frame_images_path = os.path.join(base_path,  'snow Frame/k')
snow_hi_frame_images_path = os.path.join(base_path,  'snow Frame/hi')

snow_real_images = load_images_from_folder(snow_real_images_path)
snow_k_frame_images = load_images_from_folder(snow_k_frame_images_path)
snow_hi_frame_images = load_images_from_folder(snow_hi_frame_images_path)

snow_Frame_images = snow_k_frame_images + snow_hi_frame_images

import matplotlib.pyplot as plt

"""#City 끼리 유사도 계산"""

thresholds = np.arange(0.1, 1.1, 0.1)
performance_per_threshold_City_City = []

best_threshold = None
best_performance = 0

for threshold in thresholds:
    correct_predictions = 0
    total_comparisons = 0
    for f in City_Frame_images:
        for ri in City_real_images:
            similarity = calculate_similarity_by_corr(f, ri)
            if similarity >= threshold:
                correct_predictions += 1
            total_comparisons += 1

    performance = correct_predictions / total_comparisons
    performance_per_threshold_City_City.append(performance)

    if performance > best_performance:
        best_performance = performance
        best_threshold = threshold

# 성능(예: 정확도)에 따른 바 그래프 그리기
plt.bar(thresholds, performance_per_threshold_City_City, width=0.05)
plt.xlabel('Threshold')
plt.ylabel('Performance')
plt.title('Performance vs. Threshold By CORR')
plt.show()

print(f"Best threshold: {best_threshold} with performance: {best_performance}")

performance_per_threshold_City_City

thresholds = np.arange(0.1, 1.1, 0.1)
performance_per_threshold = []

best_threshold = None
best_performance = 0

for threshold in thresholds:
    correct_predictions = 0
    total_comparisons = 0
    for kf in City_Frame_images:
        for ri in City_real_images:
            similarity = calculate_similarity_by_bhat(kf, ri)
            if similarity >= threshold:
                correct_predictions += 1
            total_comparisons += 1

    performance = correct_predictions / total_comparisons
    performance_per_threshold.append(performance)

    if performance > best_performance:
        best_performance = performance
        best_threshold = threshold

# 성능(예: 정확도)에 따른 바 그래프 그리기
plt.bar(thresholds, performance_per_threshold, width=0.05)
plt.xlabel('Threshold')
plt.ylabel('Performance')
plt.title('Performance vs. Threshold By Bhat')
plt.show()

print(f"Best threshold: {best_threshold} with performance: {best_performance}")

performance_per_threshold

"""#City와 mountain 계산"""

thresholds = np.arange(0.1, 1.1, 0.1)
performance_per_threshold_City_Mountain = []

best_threshold = None
best_performance = 0

for threshold in thresholds:
    correct_predictions = 0
    total_comparisons = 0
    for f in City_Frame_images:
        for ri in mountain_real_images:
            similarity = calculate_similarity_by_corr(f, ri)
            if similarity >= threshold:
                correct_predictions += 1
            total_comparisons += 1

    performance = correct_predictions / total_comparisons
    performance_per_threshold_City_Mountain.append(performance)

    if performance > best_performance:
        best_performance = performance
        best_threshold = threshold

# 성능(예: 정확도)에 따른 바 그래프 그리기
plt.bar(thresholds, performance_per_threshold_City_Mountain, width=0.05)
plt.xlabel('Threshold')
plt.ylabel('Performance')
plt.title('Performance vs. Threshold By CORR')
plt.show()

print(f"Best threshold: {best_threshold} with performance: {best_performance}")

print(performance_per_threshold_City_City)

print(performance_per_threshold_City_Mountain)

"""# 이제 이걸 함수로"""

def thresholds_calculator_corr(frame,image) :
  thresholds = np.arange(0.1, 1.1, 0.1)
  performance_per_threshold = []

  best_threshold = None
  best_performance = 0

  for threshold in thresholds:
      correct_predictions = 0
      total_comparisons = 0
      for f in frame:
          for ri in image:
              similarity = calculate_similarity_by_corr(f, ri)
              if similarity >= threshold:
                  correct_predictions += 1
              total_comparisons += 1

      performance = correct_predictions / total_comparisons
      performance_per_threshold.append(performance)

      if performance > best_performance:
          best_performance = performance
          best_threshold = threshold


  print(f"Best threshold: {best_threshold} with performance: {best_performance}")

  return performance_per_threshold

def draw_threshold_bar(result,tt) :
  thresholds = np.arange(0.1, 1.1, 0.1)
  # 성능(예: 정확도)에 따른 바 그래프 그리기
  plt.bar(thresholds, result, width=0.05)
  plt.xlabel('Threshold')
  plt.ylabel('Performance')
  plt.title('Performance vs. Threshold By CORR',tt)
  plt.show()

Frames = {'City':City_Frame_images,'Ocean' : Ocean_Frame_images ,
          'desert':desert_Frame_images,'grassland' : grassland_Frame_images ,
          'mountain': mountain_Frame_images,'snow' : snow_Frame_images }

Images = {'City':City_real_images,'Ocean' : Ocean_real_images ,
          'desert':desert_real_images,'grassland' : grassland_real_images ,
          'mountain': mountain_real_images,'snow' : snow_real_images }

def thresholds_save_corr(frames, images):
    results = {}

    for frame in frames:
        for image in images:
            performance_per_threshold = []
            thresholds = np.arange(0.1, 1.1, 0.1)

            best_threshold = None
            best_performance = 0

            for threshold in thresholds:
                correct_predictions = 0
                total_comparisons = 0
                for f in frames[frame]:
                    for ri in images[image]:
                        similarity = calculate_similarity_by_corr(f,ri)
                        if similarity >= threshold:
                            correct_predictions += 1
                        total_comparisons += 1

                performance = correct_predictions / total_comparisons
                performance_per_threshold.append(performance)
            results[(frame, image)] = performance_per_threshold

    return results

final_result = thresholds_save_corr(Frames, Images)

import matplotlib.pyplot as plt

def draw_all_threshold_bars(results):
    fig, axes = plt.subplots(6, 6, figsize=(20, 20))  # 6x6 subplot 생성
    fig.subplots_adjust(hspace=0.5, wspace=0.5)  # subplot 간 간격 조정

    thresholds = np.arange(0.1, 1.1, 0.1)
    for idx, ((frame_name, image_name), performance) in enumerate(results.items()):
        row, col = divmod(idx, 6)
        ax = axes[row, col]
        ax.bar(thresholds, performance, width=0.05)
        ax.set_title(f'{frame_name} vs {image_name}')
        ax.set_xlabel('Threshold')
        ax.set_ylabel('Performance')

    plt.show()

draw_all_threshold_bars(final_result)

def thresholds_save_bhat(frames, images):
    results = {}

    for frame in frames:
        for image in images:
            performance_per_threshold = []
            thresholds = np.arange(0.1, 1.1, 0.1)

            best_threshold = None
            best_performance = 0

            for threshold in thresholds:
                correct_predictions = 0
                total_comparisons = 0
                for f in frames[frame]:
                    for ri in images[image]:
                        similarity = calculate_similarity_by_bhat(f,ri)
                        if similarity >= threshold:
                            correct_predictions += 1
                        total_comparisons += 1

                performance = correct_predictions / total_comparisons
                performance_per_threshold.append(performance)
            results[(frame, image)] = performance_per_threshold

    return results

final_result_bhat = thresholds_save_bhat(Frames, Images)

draw_all_threshold_bars(final_result_bhat)

"""#corr이 좋아보인다."""

final_result

import numpy as np

# 결과 딕셔너리에서 각 threshold 별 평균 정확도 계산
def calculate_average_accuracy(results):
    threshold_count = len(next(iter(results.values())))
    average_accuracies = [0] * threshold_count

    for accuracies in results.values():
        for i, acc in enumerate(accuracies):
            average_accuracies[i] += acc

    # 평균을 구하기 위해 전체 카테고리 쌍의 수로 나눔
    total_pairs = len(results)
    average_accuracies = [acc / total_pairs for acc in average_accuracies]

    return average_accuracies

# 적절한 threshold 찾기
average_accuracies = calculate_average_accuracy(final_result)
best_threshold_idx = np.argmax(average_accuracies)
best_threshold = np.arange(0.1, 1.1, 0.1)[best_threshold_idx]

print(f"Best threshold: {best_threshold} with average performance: {average_accuracies[best_threshold_idx]}")

"""위의 코드는 당연하게 0.1이 나온다...!! 따라서 TP, FP를 이용해보자."""

def calculate_tp_fp_rates(results, category):
    thresholds = np.arange(0.1, 1.1, 0.1)
    tp_fp_rates = []

    for idx, threshold in enumerate(thresholds):
        tp = sum(results[(cat, cat)][idx] for cat in category)
        all_positives = sum(results[(frame, image)][idx] for frame in category for image in category )
        fp = all_positives - tp

        tp_rate = tp / len(category)
        fp_rate = fp / (len(category) * (len(category) - 1))

        tp_fp_rates.append((threshold, tp_rate, fp_rate))

    return tp_fp_rates

# 예시: 카테고리 리스트를 사용하여 TP와 FP 비율 계산
category_list = ["City", "Ocean", "desert", "grassland", "mountain", "snow"]
tp_fp_rates = calculate_tp_fp_rates(final_result, category_list)

# TP와 FP 비율 출력
for threshold, tp_rate, fp_rate in tp_fp_rates:
    print(f"Threshold: {threshold}, TP Rate: {tp_rate}, FP Rate: {fp_rate}")

our_threshold = 0.5